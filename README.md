# Порівняння алгоритмів сортування

## Опис
Мета роботи — порівняти ефективність трьох алгоритмів сортування на різних обсягах даних:
1. **Insertion Sort** (Вставками) — $O(n^2)$.
2. **Merge Sort** (Злиттям) — $O(n \log n)$.
3. **Timsort** (Вбудований `sorted`) — Гібридний алгоритм.

## Результати вимірювань (сек)

| Size | Insertion | Merge | Timsort |
| :--- | :--- | :--- | :--- |
| **100** | 0.00013 | 0.00011 | 0.00001 |
| **1000** | 0.01331 | 0.00222 | 0.00013 |
| **5000** | 0.36098 | 0.00731 | 0.00044 |

## Аналіз

### 1. Insertion Sort
* **Вердикт:** Ефективний лише на дуже малих масивах.
* **Причина:** Складність $O(n^2)$. При збільшенні даних у 10 разів, час зростає приблизно у 100 разів. На 5000 елементів він вже критично повільний.

### 2. Merge Sort
* **Вердикт:** Чудово справляється з великими даними.
* **Причина:** Складність $O(n \log n)$. Час зростає передбачувано і помірно, значно випереджаючи сортування вставками на великих обсягах.

### 3. Timsort (built-in)
* **Вердикт:** Абсолютний переможець.
* **Причина:**
    * **Гібридність:** Поєднує логіку вставок (для малих частин) та злиття (для великих).
    * **Оптимізація C:** Реалізований на мові C всередині Python, що дає величезний приріст швидкості порівняно з чистим Python-кодом.

## Висновок
Вбудований алгоритм **Timsort** є найефективнішим. Він на порядки швидший за самописні реалізації завдяки комбінації ефективних підходів та низькорівневій оптимізації. У реальних задачах слід завжди використовувати стандартні функції `sorted()` або `.sort()`.